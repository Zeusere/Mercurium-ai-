import { createReadStream } from 'node:fs';
import { appendFile, rename, stat } from 'node:fs/promises';
import { createInterface } from 'node:readline/promises';
import { appendForwardSlash, prependForwardSlash, removeLeadingForwardSlash, } from '@astrojs/internal-helpers/path';
import { createRedirectsFromAstroRoutes } from '@astrojs/underscore-redirects';
import { AstroError } from 'astro/errors';
import { getPlatformProxy } from 'wrangler';
import { createRoutesFile, getParts } from './utils/generate-routes-json.js';
import { setImageConfig } from './utils/image-config.js';
import { wasmModuleLoader } from './utils/wasm-module-loader.js';
export default function createIntegration(args) {
    let _config;
    return {
        name: '@astrojs/cloudflare',
        hooks: {
            'astro:config:setup': ({ command, config, updateConfig, logger }) => {
                updateConfig({
                    build: {
                        client: new URL(`.${prependForwardSlash(appendForwardSlash(config.base))}`, config.outDir),
                        server: new URL('./_worker.js/', config.outDir),
                        serverEntry: 'index.js',
                        redirects: false,
                    },
                    vite: {
                        // load .wasm files as WebAssembly modules
                        plugins: [
                            wasmModuleLoader({
                                disabled: !args?.wasmModuleImports,
                            }),
                        ],
                    },
                    image: setImageConfig(args?.imageService ?? 'DEFAULT', config.image, command, logger),
                });
            },
            'astro:config:done': ({ setAdapter, config }) => {
                _config = config;
                if (config.output === 'static') {
                    throw new AstroError('[@astrojs/cloudflare] `output: "server"` or `output: "hybrid"` is required to use this adapter. Otherwise, this adapter is not necessary to deploy a static site to Cloudflare.');
                }
                setAdapter({
                    name: '@astrojs/cloudflare',
                    serverEntrypoint: '@astrojs/cloudflare/entrypoints/server.advanced.js',
                    exports: ['default'],
                    adapterFeatures: {
                        functionPerRoute: false,
                        edgeMiddleware: false,
                    },
                    supportedAstroFeatures: {
                        serverOutput: 'stable',
                        hybridOutput: 'stable',
                        staticOutput: 'unsupported',
                        i18nDomains: 'experimental',
                        assets: {
                            supportKind: 'stable',
                            isSharpCompatible: false,
                            isSquooshCompatible: false,
                        },
                    },
                });
            },
            'astro:server:setup': async ({ server }) => {
                if (args?.platformProxy?.enabled === true) {
                    const platformProxy = await getPlatformProxy({
                        configPath: args.platformProxy.configPath ?? 'wrangler.toml',
                        experimentalJsonConfig: args.platformProxy.experimentalJsonConfig ?? false,
                        persist: args.platformProxy.persist ?? true,
                    });
                    const clientLocalsSymbol = Symbol.for('astro.locals');
                    server.middlewares.use(async function middleware(req, res, next) {
                        Reflect.set(req, clientLocalsSymbol, {
                            runtime: {
                                env: platformProxy.env,
                                cf: platformProxy.cf,
                                caches: platformProxy.caches,
                                ctx: platformProxy.ctx,
                            },
                        });
                        next();
                    });
                }
            },
            'astro:build:setup': ({ vite, target }) => {
                if (target === 'server') {
                    vite.resolve ||= {};
                    vite.resolve.alias ||= {};
                    const aliases = [
                        {
                            find: 'react-dom/server',
                            replacement: 'react-dom/server.browser',
                        },
                    ];
                    if (Array.isArray(vite.resolve.alias)) {
                        vite.resolve.alias = [...vite.resolve.alias, ...aliases];
                    }
                    else {
                        for (const alias of aliases) {
                            vite.resolve.alias[alias.find] = alias.replacement;
                        }
                    }
                    vite.resolve.conditions ||= [];
                    // We need those conditions, previous these conditions where applied at the esbuild step which we removed
                    // https://github.com/withastro/astro/pull/7092
                    vite.resolve.conditions.push('workerd', 'worker');
                    vite.ssr ||= {};
                    vite.ssr.target = 'webworker';
                    vite.ssr.noExternal = true;
                    if (typeof _config.vite.ssr?.external === 'undefined')
                        vite.ssr.external = [];
                    if (typeof _config.vite.ssr?.external === 'boolean')
                        vite.ssr.external = _config.vite.ssr?.external;
                    if (Array.isArray(_config.vite.ssr?.external))
                        // `@astrojs/vue` sets `@vue/server-renderer` to external
                        // https://github.com/withastro/astro/blob/e648c5575a8774af739231cfa9fc27a32086aa5f/packages/integrations/vue/src/index.ts#L119
                        // the cloudflare adapter needs to get all dependencies inlined, we use `noExternal` for that, but any `external` config overrides that
                        // therefore we need to remove `@vue/server-renderer` from the external config again
                        vite.ssr.external = _config.vite.ssr?.external.filter((entry) => entry !== '@vue/server-renderer');
                    vite.build ||= {};
                    vite.build.rollupOptions ||= {};
                    vite.build.rollupOptions.output ||= {};
                    const nodeModulesSubPaths = [
                        ...(args?.experimental?.manualChunks ?? []),
                        'node_modules/react/',
                        'node_modules/react-dom/',
                        'node_modules/solid-js/',
                    ];
                    // @ts-expect-error
                    vite.build.rollupOptions.output.manualChunks ||= (id) => {
                        for (const nodeModulesSubPath of nodeModulesSubPaths) {
                            if (id.includes(nodeModulesSubPath))
                                return `nm_${nodeModulesSubPath.replace('node_modules/', '').replace(/\//g, '_')}`;
                        }
                    };
                    // @ts-expect-error
                    vite.build.rollupOptions.output.banner ||=
                        'globalThis.process ??= {}; globalThis.process.env ??= {};';
                    vite.build.rollupOptions.external = _config.vite.build?.rollupOptions?.external ?? [];
                    // Cloudflare env is only available per request. This isn't feasible for code that access env vars
                    // in a global way, so we shim their access as `process.env.*`. This is not the recommended way for users to access environment variables. But we'll add this for compatibility for chosen variables. Mainly to support `@astrojs/db`
                    vite.define = {
                        'process.env': 'process.env',
                        ...vite.define,
                    };
                }
                // we thought that vite config inside `if (target === 'server')` would not apply for client
                // but it seems like the same `vite` reference is used for both
                // so we need to reset the previous conflicting setting
                // in the future we should look into a more robust solution
                if (target === 'client') {
                    vite.resolve ||= {};
                    vite.resolve.conditions ||= [];
                    vite.resolve.conditions = vite.resolve.conditions.filter((c) => c !== 'workerd' && c !== 'worker');
                    vite.build ||= {};
                    vite.build.rollupOptions ||= {};
                    vite.build.rollupOptions.output ||= {};
                    //@ts-expect-error
                    vite.build.rollupOptions.output.manualChunks ||= undefined;
                }
            },
            'astro:build:done': async ({ pages, routes, dir, logger }) => {
                const PLATFORM_FILES = ['_headers', '_redirects', '_routes.json'];
                if (_config.base !== '/') {
                    for (const file of PLATFORM_FILES) {
                        try {
                            await rename(new URL(file, _config.build.client), new URL(file, _config.outDir));
                        }
                        catch (e) {
                            logger.error(`There was an error moving ${file} to the root of the output directory.`);
                        }
                    }
                }
                let redirectsExists = false;
                try {
                    const redirectsStat = await stat(new URL('./_redirects', _config.outDir));
                    if (redirectsStat.isFile()) {
                        redirectsExists = true;
                    }
                }
                catch (error) {
                    redirectsExists = false;
                }
                const redirects = [];
                if (redirectsExists) {
                    const rl = createInterface({
                        input: createReadStream(new URL('./_redirects', _config.outDir)),
                        crlfDelay: Number.POSITIVE_INFINITY,
                    });
                    for await (const line of rl) {
                        const parts = line.split(' ');
                        if (parts.length >= 2) {
                            const p = removeLeadingForwardSlash(parts[0])
                                .split('/')
                                .filter(Boolean)
                                .map((s) => {
                                const syntax = s
                                    .replace(/\/:.*?(?=\/|$)/g, '/*')
                                    // remove query params as they are not supported by cloudflare
                                    .replace(/\?.*$/, '');
                                return getParts(syntax);
                            });
                            redirects.push(p);
                        }
                    }
                }
                let routesExists = false;
                try {
                    const routesStat = await stat(new URL('./_routes.json', _config.outDir));
                    if (routesStat.isFile()) {
                        routesExists = true;
                    }
                }
                catch (error) {
                    routesExists = false;
                }
                if (!routesExists) {
                    await createRoutesFile(_config, logger, routes, pages, redirects, args?.routes?.extend?.include, args?.routes?.extend?.exclude);
                }
                const redirectRoutes = [];
                for (const route of routes) {
                    if (route.type === 'redirect')
                        redirectRoutes.push([route, '']);
                }
                const trueRedirects = createRedirectsFromAstroRoutes({
                    config: _config,
                    routeToDynamicTargetMap: new Map(Array.from(redirectRoutes)),
                    dir,
                });
                if (!trueRedirects.empty()) {
                    try {
                        await appendFile(new URL('./_redirects', _config.outDir), trueRedirects.print());
                    }
                    catch (error) {
                        logger.error('Failed to write _redirects file');
                    }
                }
            },
        },
    };
}
